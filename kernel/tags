!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADDR_BASE	config.h	17;"	d
ALOCATORS	kmalloc.c	5;"	d	file:
BITS	palloc.c	4;"	d	file:
BLACK	screen.c	/^	BLACK = 0,$/;"	e	enum:ScreenColor	file:
BLUE	screen.c	/^	BLUE,$/;"	e	enum:ScreenColor	file:
BROWN	screen.c	/^	BROWN,$/;"	e	enum:ScreenColor	file:
CFLAGS	Makefile	/^CFLAGS=-nostdlib -nostdinc -fno-builtin -fno-stack-protector -pipe -Werror -march=native ${OPTIMIZE}$/;"	m
COUNT	kmalloc.c	7;"	d	file:
CYAN	screen.c	/^	CYAN,$/;"	e	enum:ScreenColor	file:
DARKGRAY	screen.c	/^	DARKGRAY,$/;"	e	enum:ScreenColor	file:
DEFAULT_PRIORITY	config.h	9;"	d
EI_NIDENT	elf.h	6;"	d
ENTRIES	palloc.c	5;"	d	file:
GDT_ENTRIES	gdt.c	4;"	d	file:
GREEN	screen.c	/^	GREEN,$/;"	e	enum:ScreenColor	file:
IDT_IRQ	interrupts.c	214;"	d	file:
IDT_ISR	interrupts.c	212;"	d	file:
INT_RETURN	interrupts.h	6;"	d
IOAPIC_BASE	interrupts.h	18;"	d
IOAPIC_DISABLE	interrupts.c	10;"	d	file:
IOAPIC_REDIR_BASE	interrupts.h	15;"	d
IRQ	interrupts.c	213;"	d	file:
IRQ	isr.s	/^IRQ 128$/;"	l
IRQ	isr.s	/^IRQ 200$/;"	l
IRQ	isr.s	/^IRQ 201$/;"	l
IRQ	isr.s	/^IRQ 202$/;"	l
IRQ	isr.s	/^IRQ 203$/;"	l
IRQ	isr.s	/^IRQ 204$/;"	l
IRQ	isr.s	/^IRQ 205$/;"	l
IRQ	isr.s	/^IRQ 206$/;"	l
IRQ	isr.s	/^IRQ 207$/;"	l
IRQ	isr.s	/^IRQ 208$/;"	l
IRQ	isr.s	/^IRQ 209$/;"	l
IRQ	isr.s	/^IRQ 210$/;"	l
IRQ	isr.s	/^IRQ 211$/;"	l
IRQ	isr.s	/^IRQ 212$/;"	l
IRQ	isr.s	/^IRQ 213$/;"	l
IRQ	isr.s	/^IRQ 214$/;"	l
IRQ	isr.s	/^IRQ 215$/;"	l
IRQ	isr.s	/^IRQ 216$/;"	l
IRQ	isr.s	/^IRQ 217$/;"	l
IRQ	isr.s	/^IRQ 218$/;"	l
IRQ	isr.s	/^IRQ 219$/;"	l
ISR	interrupts.c	211;"	d	file:
ISR_EC	isr.s	/^ISR_EC 10$/;"	l
ISR_EC	isr.s	/^ISR_EC 11$/;"	l
ISR_EC	isr.s	/^ISR_EC 12$/;"	l
ISR_EC	isr.s	/^ISR_EC 13$/;"	l
ISR_EC	isr.s	/^ISR_EC 14$/;"	l
ISR_EC	isr.s	/^ISR_EC 8$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 0$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 1$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 15$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 16$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 17$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 18$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 19$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 2$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 20$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 21$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 22$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 23$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 24$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 25$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 26$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 27$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 28$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 29$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 3$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 30$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 31$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 4$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 5$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 6$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 7$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 80$/;"	l
ISR_NEC	isr.s	/^ISR_NEC 9$/;"	l
KERNEL_PAGE_DIR_PHYS	paging.h	19;"	d
LAPIC_BASE	interrupts.h	17;"	d
LAPIC_EOI	interrupts.h	10;"	d
LAPIC_ERR	interrupts.h	12;"	d
LAPIC_ID	interrupts.h	8;"	d
LAPIC_PERF_MON	interrupts.h	14;"	d
LAPIC_SIR	interrupts.h	11;"	d
LAPIC_TIMER	interrupts.h	13;"	d
LAPIC_TPR	interrupts.h	9;"	d
LDFLAGS	Makefile	/^LDFLAGS=-Tlink.ld -nostdlib -nodefaultlibs$/;"	m
LIGHTBLUE	screen.c	/^	LIGHTBLUE,$/;"	e	enum:ScreenColor	file:
LIGHTBROWN	screen.c	/^	LIGHTBROWN,$/;"	e	enum:ScreenColor	file:
LIGHTCYAN	screen.c	/^	LIGHTCYAN,$/;"	e	enum:ScreenColor	file:
LIGHTGREEN	screen.c	/^	LIGHTGREEN,$/;"	e	enum:ScreenColor	file:
LIGHTGREY	screen.c	/^	LIGHTGREY,$/;"	e	enum:ScreenColor	file:
LIGHTMAGENTA	screen.c	/^	LIGHTMAGENTA,$/;"	e	enum:ScreenColor	file:
LIGHTRED	screen.c	/^	LIGHTRED,$/;"	e	enum:ScreenColor	file:
MAGENTA	screen.c	/^	MAGENTA,$/;"	e	enum:ScreenColor	file:
MAX_CPU	config.h	7;"	d
MAX_PRIORITIES	config.h	8;"	d
MAX_PROCESSES	config.h	5;"	d
MAX_QUEUES	config.h	6;"	d
MAX_THREADS	config.h	4;"	d
MEMALOC_SIZE	kmalloc.c	4;"	d	file:
MP_config	cpu.h	/^struct MP_config{$/;"	s
MP_config::base_tab_len	cpu.h	/^	uint16 base_tab_len;$/;"	m	struct:MP_config	access:public
MP_config::checksum	cpu.h	/^	uint8 checksum;$/;"	m	struct:MP_config	access:public
MP_config::entry_count	cpu.h	/^	uint16 entry_count;$/;"	m	struct:MP_config	access:public
MP_config::ext_tab_checksum	cpu.h	/^	uint8 ext_tab_checksum;$/;"	m	struct:MP_config	access:public
MP_config::ext_tab_len	cpu.h	/^	uint16 ext_tab_len;$/;"	m	struct:MP_config	access:public
MP_config::lapic_addr	cpu.h	/^	uint32 lapic_addr;$/;"	m	struct:MP_config	access:public
MP_config::oem_id	cpu.h	/^	uint8 oem_id[8];$/;"	m	struct:MP_config	access:public
MP_config::oem_table_ptr	cpu.h	/^	uint32 oem_table_ptr;$/;"	m	struct:MP_config	access:public
MP_config::oem_table_size	cpu.h	/^	uint16 oem_table_size;$/;"	m	struct:MP_config	access:public
MP_config::prod_id	cpu.h	/^	uint8 prod_id[12];$/;"	m	struct:MP_config	access:public
MP_config::signature	cpu.h	/^	uint8 signature[4];$/;"	m	struct:MP_config	access:public
MP_config::specRev	cpu.h	/^	uint8 specRev;$/;"	m	struct:MP_config	access:public
MP_float_ptr	cpu.h	/^struct MP_float_ptr{$/;"	s
MP_float_ptr::checksum	cpu.h	/^	uint8 checksum;$/;"	m	struct:MP_float_ptr	access:public
MP_float_ptr::config	cpu.h	/^	struct MP_config *config;$/;"	m	struct:MP_float_ptr	typeref:struct:MP_float_ptr::MP_config	access:public
MP_float_ptr::features	cpu.h	/^	uint8 features[2];$/;"	m	struct:MP_float_ptr	access:public
MP_float_ptr::length	cpu.h	/^	uint8 length;$/;"	m	struct:MP_float_ptr	access:public
MP_float_ptr::reserved	cpu.h	/^	uint8 reserved[3];$/;"	m	struct:MP_float_ptr	access:public
MP_float_ptr::signature	cpu.h	/^	uint8 signature[4];$/;"	m	struct:MP_float_ptr	access:public
MP_float_ptr::version	cpu.h	/^	uint8 version;$/;"	m	struct:MP_float_ptr	access:public
MP_ioapic_entry	cpu.h	/^struct MP_ioapic_entry{$/;"	s
MP_ioapic_entry::addr	cpu.h	/^	uint32 addr;$/;"	m	struct:MP_ioapic_entry	access:public
MP_ioapic_entry::enabled	cpu.h	/^	uint8 enabled;$/;"	m	struct:MP_ioapic_entry	access:public
MP_ioapic_entry::id	cpu.h	/^	uint8 id;$/;"	m	struct:MP_ioapic_entry	access:public
MP_ioapic_entry::type	cpu.h	/^	uint8 type;$/;"	m	struct:MP_ioapic_entry	access:public
MP_ioapic_entry::ver	cpu.h	/^	uint8 ver;$/;"	m	struct:MP_ioapic_entry	access:public
MP_proc_entry	cpu.h	/^struct MP_proc_entry{$/;"	s
MP_proc_entry::cpu_feat_flags	cpu.h	/^	uint32 cpu_feat_flags;$/;"	m	struct:MP_proc_entry	access:public
MP_proc_entry::cpu_flags	cpu.h	/^	uint8 cpu_flags;$/;"	m	struct:MP_proc_entry	access:public
MP_proc_entry::cpu_sig	cpu.h	/^	uint8 cpu_sig[4];$/;"	m	struct:MP_proc_entry	access:public
MP_proc_entry::lapic_id	cpu.h	/^	uint8 lapic_id;$/;"	m	struct:MP_proc_entry	access:public
MP_proc_entry::lapic_ver	cpu.h	/^	uint8 lapic_ver;$/;"	m	struct:MP_proc_entry	access:public
MP_proc_entry::type	cpu.h	/^	uint8 type;$/;"	m	struct:MP_proc_entry	access:public
NODES	kmalloc.c	6;"	d	file:
NULL_PROCESS	multitasking.h	12;"	d
NULL_THREAD	multitasking.h	8;"	d
OBJ	Makefile	/^OBJ=$(subst .s,.o,$(SRC:.c=.o))$/;"	m
OPTIMIZE	Makefile	/^OPTIMIZE=-ggdb$/;"	m
PAGES	config.h	13;"	d
PAGE_4MBPAGE	paging.h	14;"	d
PAGE_ACCESSED	paging.h	12;"	d
PAGE_DIRTY	paging.h	13;"	d
PAGE_DIR_VIRT_ADDR	paging.h	17;"	d
PAGE_GLOBAL	paging.h	15;"	d
PAGE_NOCACHE	paging.h	11;"	d
PAGE_PRESENT	paging.h	7;"	d
PAGE_SHIFT	config.h	11;"	d
PAGE_SIZE	config.h	12;"	d
PAGE_USERMODE	paging.h	9;"	d
PAGE_WRITABLE	paging.h	8;"	d
PAGE_WRITETHR	paging.h	10;"	d
PRINT_FIELD	interrupts.c	32;"	d	file:
PROC_EXISTS	multitasking.h	13;"	d
PROC_MAX_QUEUES	multitasking.h	15;"	d
PROC_MAX_STREAMS	config.h	15;"	d
QUEUE_LEN	ipc.h	13;"	d
RED	screen.c	/^	RED,$/;"	e	enum:ScreenColor	file:
RSA_SIZE	memory.c	7;"	d	file:
SCREEN_HEIGHT	screen.c	/^static const int SCREEN_HEIGHT = 25;$/;"	v	file:
SCREEN_WIDTH	screen.c	/^static const int SCREEN_WIDTH = 80;$/;"	v	file:
SRC	Makefile	/^SRC=$(wildcard *.[c,s])$/;"	m
STACK_OFFSET	config.h	20;"	d
SYS_CALL_CONNECT	system_calls.h	5;"	d
SYS_CALL_DISCONNECT	system_calls.h	6;"	d
SYS_CALL_EXIT	system_calls.h	4;"	d
SYS_CALL_MMAP	system_calls.h	10;"	d
SYS_CALL_QUERY	system_calls.h	12;"	d
SYS_CALL_RECEIVE	system_calls.h	8;"	d
SYS_CALL_REGISTER	system_calls.h	11;"	d
SYS_CALL_SEND	system_calls.h	7;"	d
SYS_CALL_WAIT	system_calls.h	9;"	d
Scheduler	scheduler.c	/^struct Scheduler$/;"	s	file:
ScreenColor	screen.c	/^enum ScreenColor{$/;"	g	file:
TGT	Makefile	/^TGT=kernel.img$/;"	m
THREAD_EXISTS	multitasking.h	9;"	d
THREAD_IS_RDY	multitasking.h	10;"	d
VGA_HIGH_CURSOR	ports.h	8;"	d
VGA_LOW_CURSOR	ports.h	9;"	d
VGA_PORT_PREPARE	ports.h	6;"	d
VGA_PORT_SEND	ports.h	7;"	d
VIRT_TO_PHYS	config.h	18;"	d
WHITE	screen.c	/^	WHITE$/;"	e	enum:ScreenColor	file:
_CONFIG_H	config.h	2;"	d
_CPU_H	cpu.h	2;"	d
_DRIVERS_H	drivers.h	2;"	d
_ELF_H	elf.h	2;"	d
_GDT_H	gdt.h	2;"	d
_INTERRUPTS_H	interrupts.h	2;"	d
_IPC_H	ipc.h	2;"	d
_KMALLOC_H	kmalloc.h	2;"	d
_LOCKS_H	locks.h	2;"	d
_MBOOT_H	mboot.h	2;"	d
_MEMORY_H	memory.h	2;"	d
_MULTITASKING_H	multitasking.h	2;"	d
_PAGING_H	paging.h	2;"	d
_PALLOC_H	palloc.h	2;"	d
_PORTS_H	ports.h	2;"	d
_SCHEDULER_H	scheduler.h	2;"	d
_SCREEN_H	screen.h	2;"	d
_SYSCALL	syscall.h	2;"	d
_SYSTEM_CALLS_H	system_calls.h	2;"	d
_UTIL_H	util.h	2;"	d
access	gdt.c	/^	uint8 access;$/;"	m	struct:gdt_entry	file:	access:public
addr	cpu.h	/^	uint32 addr;$/;"	m	struct:MP_ioapic_entry	access:public
addr	kmalloc.c	/^	uint32 addr;$/;"	m	struct:mem_node	file:	access:public
allocator	kmalloc.c	/^struct mem_allocator allocator;$/;"	v	typeref:struct:mem_allocator
apic_init	interrupts.c	/^void apic_init()$/;"	f
apic_init	interrupts.h	/^void apic_init();$/;"	p	signature:()
base	gdt.c	/^	uint32 base;$/;"	m	struct:gdt	file:	access:public
base	interrupts.c	/^	uint32 base;$/;"	m	struct:idt	file:	access:public
base	interrupts.c	/^static int base = 0;$/;"	v	file:
base_high	gdt.c	/^	uint8 base_high;$/;"	m	struct:gdt_entry	file:	access:public
base_high	interrupts.c	/^	uint16 base_high;$/;"	m	struct:idt_entry	file:	access:public
base_high	mboot.h	/^	uint32 base_high;$/;"	m	struct:mmap	access:public
base_low	gdt.c	/^	uint16 base_low;$/;"	m	struct:gdt_entry	file:	access:public
base_low	interrupts.c	/^	uint16 base_low;$/;"	m	struct:idt_entry	file:	access:public
base_low	mboot.h	/^	uint32 base_low;$/;"	m	struct:mmap	access:public
base_middle	gdt.c	/^	uint8 base_middle;$/;"	m	struct:gdt_entry	file:	access:public
base_tab_len	cpu.h	/^	uint16 base_tab_len;$/;"	m	struct:MP_config	access:public
boot_device	mboot.c	/^	uint32 boot_device;$/;"	m	struct:mboot	file:	access:public
bss	multitasking.h	/^	struct proc_section bss;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
buf	ipc.h	/^	uint8 buf[QUEUE_LEN];$/;"	m	struct:msg_queue	access:public
call_kernel	entry.s	/^call_kernel:$/;"	l
checksum	cpu.h	/^	uint8 checksum;$/;"	m	struct:MP_config	access:public
checksum	cpu.h	/^	uint8 checksum;$/;"	m	struct:MP_float_ptr	access:public
clear_line	screen.c	/^static void clear_line(uint8 lineno)$/;"	f	file:	signature:(uint8 lineno)
cmdline	mboot.c	/^	uint32 cmdline;$/;"	m	struct:mboot	file:	access:public
common_handler	interrupts.c	/^void common_handler(struct thread_state *regs)$/;"	f	signature:(struct thread_state *regs)
config	cpu.h	/^	struct MP_config *config;$/;"	m	struct:MP_float_ptr	typeref:struct:MP_float_ptr::MP_config	access:public
cpu_feat_flags	cpu.h	/^	uint32 cpu_feat_flags;$/;"	m	struct:MP_proc_entry	access:public
cpu_flags	cpu.h	/^	uint8 cpu_flags;$/;"	m	struct:MP_proc_entry	access:public
cpu_sig	cpu.h	/^	uint8 cpu_sig[4];$/;"	m	struct:MP_proc_entry	access:public
cpuid	cpu.c	/^uint32 cpuid()$/;"	f
cpuid	cpu.h	/^uint32 cpuid();$/;"	p	signature:()
cr3	gdt.c	/^	uint32 cr3;$/;"	m	struct:tss_entry	file:	access:public
cs	gdt.c	/^	uint32 cs;$/;"	m	struct:tss_entry	file:	access:public
cs	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
cur_style	screen.c	/^static uint8 cur_style = (BLACK << 4 | LIGHTGREY);$/;"	v	file:
cur_thread	multitasking.h	/^	thread_id cur_thread;$/;"	m	struct:shed_data	access:public
cur_x	screen.c	/^static uint8 cur_x = 0;$/;"	v	file:
cur_y	screen.c	/^static uint8 cur_y = 0;$/;"	v	file:
current_priority	multitasking.h	/^	uint32 current_priority;$/;"	m	struct:thread	access:public
data	multitasking.h	/^	struct proc_section data;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
driver	drivers.h	/^struct driver$/;"	s
driver::name	drivers.h	/^	char name[32];$/;"	m	struct:driver	access:public
driver::pid	drivers.h	/^	proc_id pid;$/;"	m	struct:driver	access:public
drivers	drivers.c	/^struct driver drivers[128];$/;"	v	typeref:struct:driver
drivers_init	drivers.c	/^void drivers_init()$/;"	f
drivers_init	drivers.h	/^void drivers_init();$/;"	p	signature:()
ds	gdt.c	/^	uint32 ds;$/;"	m	struct:tss_entry	file:	access:public
ds	interrupts.h	/^	uint32 ds;$/;"	m	struct:thread_state	access:public
dump_idt	interrupts.c	/^void dump_idt()$/;"	f
e_ehsize	elf.h	/^	uint16 e_ehsize;$/;"	m	struct:elf_header	access:public
e_entry	elf.h	/^	uint32 e_entry;$/;"	m	struct:elf_header	access:public
e_flags	elf.h	/^	uint32 e_flags;$/;"	m	struct:elf_header	access:public
e_ident	elf.h	/^	unsigned char e_ident[EI_NIDENT];$/;"	m	struct:elf_header	access:public
e_machine	elf.h	/^	uint16 e_machine;$/;"	m	struct:elf_header	access:public
e_phentsize	elf.h	/^	uint16 e_phentsize;$/;"	m	struct:elf_header	access:public
e_phnum	elf.h	/^	uint16 e_phnum;$/;"	m	struct:elf_header	access:public
e_phoff	elf.h	/^	uint32 e_phoff;$/;"	m	struct:elf_header	access:public
e_shentsize	elf.h	/^	uint16 e_shentsize;$/;"	m	struct:elf_header	access:public
e_shnum	elf.h	/^	uint16 e_shnum;$/;"	m	struct:elf_header	access:public
e_shoff	elf.h	/^	uint32 e_shoff;$/;"	m	struct:elf_header	access:public
e_shtrndx	elf.h	/^	uint16 e_shtrndx;$/;"	m	struct:elf_header	access:public
e_type	elf.h	/^	uint16 e_type;$/;"	m	struct:elf_header	access:public
e_version	elf.h	/^	uint32 e_version;$/;"	m	struct:elf_header	access:public
eax	gdt.c	/^	uint32 eax;$/;"	m	struct:tss_entry	file:	access:public
eax	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
ebp	gdt.c	/^	uint32 ebp;$/;"	m	struct:tss_entry	file:	access:public
ebp	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
ebp	multitasking.h	/^	uint32 ebp;$/;"	m	struct:thread	access:public
ebx	gdt.c	/^	uint32 ebx;$/;"	m	struct:tss_entry	file:	access:public
ebx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
ecx	gdt.c	/^	uint32 ecx;$/;"	m	struct:tss_entry	file:	access:public
ecx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
edi	gdt.c	/^	uint32 edi;$/;"	m	struct:tss_entry	file:	access:public
edi	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
edx	gdt.c	/^	uint32 edx;$/;"	m	struct:tss_entry	file:	access:public
edx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
eflags	gdt.c	/^	uint32 eflags;$/;"	m	struct:tss_entry	file:	access:public
eflags	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
eip	gdt.c	/^	uint32 eip;$/;"	m	struct:tss_entry	file:	access:public
eip	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
eip	multitasking.h	/^	uint32 eip;$/;"	m	struct:thread	access:public
elf_header	elf.h	/^struct elf_header{$/;"	s
elf_header::e_ehsize	elf.h	/^	uint16 e_ehsize;$/;"	m	struct:elf_header	access:public
elf_header::e_entry	elf.h	/^	uint32 e_entry;$/;"	m	struct:elf_header	access:public
elf_header::e_flags	elf.h	/^	uint32 e_flags;$/;"	m	struct:elf_header	access:public
elf_header::e_ident	elf.h	/^	unsigned char e_ident[EI_NIDENT];$/;"	m	struct:elf_header	access:public
elf_header::e_machine	elf.h	/^	uint16 e_machine;$/;"	m	struct:elf_header	access:public
elf_header::e_phentsize	elf.h	/^	uint16 e_phentsize;$/;"	m	struct:elf_header	access:public
elf_header::e_phnum	elf.h	/^	uint16 e_phnum;$/;"	m	struct:elf_header	access:public
elf_header::e_phoff	elf.h	/^	uint32 e_phoff;$/;"	m	struct:elf_header	access:public
elf_header::e_shentsize	elf.h	/^	uint16 e_shentsize;$/;"	m	struct:elf_header	access:public
elf_header::e_shnum	elf.h	/^	uint16 e_shnum;$/;"	m	struct:elf_header	access:public
elf_header::e_shoff	elf.h	/^	uint32 e_shoff;$/;"	m	struct:elf_header	access:public
elf_header::e_shtrndx	elf.h	/^	uint16 e_shtrndx;$/;"	m	struct:elf_header	access:public
elf_header::e_type	elf.h	/^	uint16 e_type;$/;"	m	struct:elf_header	access:public
elf_header::e_version	elf.h	/^	uint32 e_version;$/;"	m	struct:elf_header	access:public
elf_load	elf.c	/^proc_id elf_load(uint8 *buf)$/;"	f	signature:(uint8 *buf)
elf_load	elf.h	/^proc_id elf_load(uint8 *buf);$/;"	p	signature:(uint8 *buf)
elf_section	elf.h	/^struct elf_section{$/;"	s
elf_section::sh_addr	elf.h	/^	uint32 sh_addr;$/;"	m	struct:elf_section	access:public
elf_section::sh_addralign	elf.h	/^	uint32 sh_addralign;$/;"	m	struct:elf_section	access:public
elf_section::sh_entsize	elf.h	/^	uint32 sh_entsize;$/;"	m	struct:elf_section	access:public
elf_section::sh_flags	elf.h	/^	uint32 sh_flags;$/;"	m	struct:elf_section	access:public
elf_section::sh_info	elf.h	/^	uint32 sh_info;$/;"	m	struct:elf_section	access:public
elf_section::sh_link	elf.h	/^	uint32 sh_link;$/;"	m	struct:elf_section	access:public
elf_section::sh_name	elf.h	/^	uint32 sh_name;$/;"	m	struct:elf_section	access:public
elf_section::sh_offset	elf.h	/^	uint32 sh_offset;$/;"	m	struct:elf_section	access:public
elf_section::sh_size	elf.h	/^	uint32 sh_size;$/;"	m	struct:elf_section	access:public
elf_section::sh_type	elf.h	/^	uint32 sh_type;$/;"	m	struct:elf_section	access:public
enabled	cpu.h	/^	uint8 enabled;$/;"	m	struct:MP_ioapic_entry	access:public
entry_count	cpu.h	/^	uint16 entry_count;$/;"	m	struct:MP_config	access:public
err	interrupts.h	/^	uint32 int_id, err;$/;"	m	struct:thread_state	access:public
es	gdt.c	/^	uint32 es;$/;"	m	struct:tss_entry	file:	access:public
esi	gdt.c	/^	uint32 esi;$/;"	m	struct:tss_entry	file:	access:public
esi	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
esp	gdt.c	/^	uint32 esp;$/;"	m	struct:tss_entry	file:	access:public
esp	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
esp	multitasking.h	/^	uint32 esp;$/;"	m	struct:thread	access:public
esp0	gdt.c	/^	uint32 esp0;$/;"	m	struct:tss_entry	file:	access:public
esp1	gdt.c	/^	uint32 esp1;$/;"	m	struct:tss_entry	file:	access:public
esp2	gdt.c	/^	uint32 esp2;$/;"	m	struct:tss_entry	file:	access:public
ext_tab_checksum	cpu.h	/^	uint8 ext_tab_checksum;$/;"	m	struct:MP_config	access:public
ext_tab_len	cpu.h	/^	uint16 ext_tab_len;$/;"	m	struct:MP_config	access:public
fake_gdt	entry.s	/^fake_gdt:$/;"	l
features	cpu.h	/^	uint8 features[2];$/;"	m	struct:MP_float_ptr	access:public
find_next_pid	multitasking.c	/^proc_id find_next_pid()$/;"	f
find_next_tid	multitasking.c	/^thread_id find_next_tid()$/;"	f
flags	interrupts.c	/^	uint8 flags;$/;"	m	struct:idt_entry	file:	access:public
flags	mboot.c	/^	uint32 flags;$/;"	m	struct:mboot	file:	access:public
flush	gdt_asm.s	/^flush:$/;"	l
fs	gdt.c	/^	uint32 fs;$/;"	m	struct:tss_entry	file:	access:public
gdt	entry.s	/^gdt:$/;"	l
gdt	gdt.c	/^static struct gdt_entry gdt[GDT_ENTRIES];$/;"	v	typeref:struct:gdt_entry	file:
gdt	gdt.c	/^struct gdt$/;"	s	file:
gdt::base	gdt.c	/^	uint32 base;$/;"	m	struct:gdt	file:	access:public
gdt::size	gdt.c	/^	uint16 size;$/;"	m	struct:gdt	file:	access:public
gdt_end	entry.s	/^gdt_end:$/;"	l
gdt_entry	gdt.c	/^struct gdt_entry$/;"	s	file:
gdt_entry::access	gdt.c	/^	uint8 access;$/;"	m	struct:gdt_entry	file:	access:public
gdt_entry::base_high	gdt.c	/^	uint8 base_high;$/;"	m	struct:gdt_entry	file:	access:public
gdt_entry::base_low	gdt.c	/^	uint16 base_low;$/;"	m	struct:gdt_entry	file:	access:public
gdt_entry::base_middle	gdt.c	/^	uint8 base_middle;$/;"	m	struct:gdt_entry	file:	access:public
gdt_entry::granularity	gdt.c	/^	uint8 granularity;$/;"	m	struct:gdt_entry	file:	access:public
gdt_entry::size_low	gdt.c	/^	uint16 size_low;$/;"	m	struct:gdt_entry	file:	access:public
gdt_flush	gdt.c	/^extern void gdt_flush(uint32 ptr);$/;"	p	file:	signature:(uint32 ptr)
gdt_flush	gdt_asm.s	/^gdt_flush:$/;"	l
gdt_init	gdt.c	/^void gdt_init()$/;"	f
gdt_init	gdt.h	/^void gdt_init();$/;"	p	signature:()
gdt_set	gdt.c	/^static void gdt_set(int32 id, uint32 base, uint32 limit, uint8 access, uint8 gran)$/;"	f	file:	signature:(int32 id, uint32 base, uint32 limit, uint8 access, uint8 gran)
gdtr	gdt.c	/^static struct gdt gdtr;$/;"	v	typeref:struct:gdt	file:
granularity	gdt.c	/^	uint8 granularity;$/;"	m	struct:gdt_entry	file:	access:public
gs	gdt.c	/^	uint32 gs;$/;"	m	struct:tss_entry	file:	access:public
handler	interrupts.h	/^typedef void (*handler)(struct thread_state regs);$/;"	t
handlers	drivers.c	/^int handlers[128];$/;"	v
head	multitasking.h	/^	thread_id head;$/;"	m	struct:shed_queue	access:public
header	ipc.h	/^	struct msg_queue_header header;$/;"	m	struct:msg_queue	typeref:struct:msg_queue::msg_queue_header	access:public
heads	kmalloc.c	/^	uint16 heads[ALOCATORS];$/;"	m	struct:mem_allocator	file:	access:public
heap	memory.c	/^uint32 heap;$/;"	v
id	cpu.h	/^	uint8 id;$/;"	m	struct:MP_ioapic_entry	access:public
idt	interrupts.c	/^struct idt {$/;"	s	file:
idt::base	interrupts.c	/^	uint32 base;$/;"	m	struct:idt	file:	access:public
idt::size	interrupts.c	/^	uint16 size;$/;"	m	struct:idt	file:	access:public
idt_entries	interrupts.c	/^static struct idt_entry idt_entries[256];$/;"	v	typeref:struct:idt_entry	file:
idt_entry	interrupts.c	/^struct idt_entry{$/;"	s	file:
idt_entry::base_high	interrupts.c	/^	uint16 base_high;$/;"	m	struct:idt_entry	file:	access:public
idt_entry::base_low	interrupts.c	/^	uint16 base_low;$/;"	m	struct:idt_entry	file:	access:public
idt_entry::flags	interrupts.c	/^	uint8 flags;$/;"	m	struct:idt_entry	file:	access:public
idt_entry::selector	interrupts.c	/^	uint16 selector;$/;"	m	struct:idt_entry	file:	access:public
idt_entry::zero	interrupts.c	/^	uint8 zero;$/;"	m	struct:idt_entry	file:	access:public
idt_flush	gdt_asm.s	/^idt_flush:$/;"	l
idt_flush	interrupts.c	/^extern void idt_flush(uint32 ptr);$/;"	p	file:	signature:(uint32 ptr)
idt_init	interrupts.c	/^void idt_init()$/;"	f
idt_init	interrupts.h	/^void idt_init();$/;"	p	signature:()
idt_set	interrupts.c	/^void idt_set(uint16 id, uint32 base, uint8 flags)$/;"	f	signature:(uint16 id, uint32 base, uint8 flags)
in_use	ipc.h	/^	uint8 in_use;$/;"	m	struct:queue_descr	access:public
init	scheduler.c	/^static void init(struct Scheduler *this)$/;"	f	file:	signature:(struct Scheduler *this)
int16	config.h	/^typedef signed short int16;$/;"	t
int2str	util.c	/^int int2str(char *str, unsigned int n, int base) {$/;"	f	signature:(char *str, unsigned int n, int base)
int32	config.h	/^typedef signed int int32;$/;"	t
int8	config.h	/^typedef signed char int8;$/;"	t
int_handler	interrupts.h	/^void int_handler(struct thread_state regs);$/;"	p	signature:(struct thread_state regs)
int_id	interrupts.h	/^	uint32 int_id, err;$/;"	m	struct:thread_state	access:public
ioapic_init	interrupts.c	/^void ioapic_init()$/;"	f
ioapic_init	interrupts.h	/^void ioapic_init();$/;"	p	signature:()
ioapic_map	interrupts.c	/^static void ioapic_map(uint32 irq, uint32 vector)$/;"	f	file:	signature:(uint32 irq, uint32 vector)
ioapic_set	interrupts.c	/^static void ioapic_set(uint32 reg, uint32 value)$/;"	f	file:	signature:(uint32 reg, uint32 value)
iomap_base	gdt.c	/^	uint16 iomap_base;$/;"	m	struct:tss_entry	file:	access:public
ipc_connect	ipc.c	/^uint8 ipc_connect(proc_id p1, proc_id p2)$/;"	f	signature:(proc_id p1, proc_id p2)
ipc_connect	ipc.h	/^uint8 ipc_connect(proc_id p1, proc_id p2);$/;"	p	signature:(proc_id p1, proc_id p2)
ipc_empty	ipc.c	/^int ipc_empty(queue_id id)$/;"	f	signature:(queue_id id)
ipc_empty	ipc.h	/^int ipc_empty(queue_id id);$/;"	p	signature:(queue_id id)
ipc_receive	ipc.c	/^int ipc_receive(queue_id id, uint8 *ptr, uint16 size)$/;"	f	signature:(queue_id id, uint8 *ptr, uint16 size)
ipc_receive	ipc.h	/^int ipc_receive(queue_id id, uint8 *ptr, uint16 size);$/;"	p	signature:(queue_id id, uint8 *ptr, uint16 size)
ipc_send	ipc.c	/^int ipc_send(queue_id id, uint8 *ptr, uint16 size)$/;"	f	signature:(queue_id id, uint8 *ptr, uint16 size)
ipc_send	ipc.h	/^int ipc_send(queue_id id, uint8 *ptr, uint16 size);$/;"	p	signature:(queue_id id, uint8 *ptr, uint16 size)
iptr	interrupts.c	/^static volatile struct idt iptr;$/;"	v	typeref:struct:idt	file:
irq_common	isr.s	/^irq_common:$/;"	l
irq_handler	interrupts.c	/^void irq_handler(struct thread_state regs)$/;"	f	signature:(struct thread_state regs)
irq_handler	interrupts.h	/^void irq_handler(struct thread_state regs);$/;"	p	signature:(struct thread_state regs)
isr_common	isr.s	/^isr_common:$/;"	l
isr_handler	interrupts.c	/^void isr_handler(struct thread_state regs)$/;"	f	signature:(struct thread_state regs)
kbrk	memory.c	/^void *kbrk(uint32 pages)$/;"	f	signature:(uint32 pages)
kbrk	memory.h	/^void *kbrk(uint32 pages);$/;"	p	signature:(uint32 pages)
kernel_size	memory.h	/^inline uint32 kernel_size();$/;"	p	signature:()
kernel_stack	multitasking.h	/^	uint32 kernel_stack;$/;"	m	struct:thread	access:public
kmain	kmain.c	/^void kmain(struct mboot *mboot, unsigned int magic)$/;"	f	signature:(struct mboot *mboot, unsigned int magic)
kmalloc	memory.c	/^void *kmalloc(uint32 size)$/;"	f	signature:(uint32 size)
kmalloc	memory.h	/^void *kmalloc(uint32 size);$/;"	p	signature:(uint32 size)
kmemcpy	util.c	/^void *kmemcpy(uint8 *destination, const uint8 *source, uint32 count)$/;"	f	signature:(uint8 *destination, const uint8 *source, uint32 count)
kmemcpy	util.h	/^void *kmemcpy(uint8 *destination, const uint8 *source, uint32 count);$/;"	p	signature:(uint8 *destination, const uint8 *source, uint32 count)
kmemset	util.c	/^void *kmemset(uint8 *ptr, uint8 value, uint32 count)$/;"	f	signature:(uint8 *ptr, uint8 value, uint32 count)
kmemset	util.h	/^void *kmemset(uint8 *ptr, uint8 value, uint32 count);$/;"	p	signature:(uint8 *ptr, uint8 value, uint32 count)
kmemset16	util.c	/^void *kmemset16(uint16 *ptr, uint16 value, uint32 count)$/;"	f	signature:(uint16 *ptr, uint16 value, uint32 count)
kmemset16	util.h	/^void *kmemset16(uint16 *ptr, uint16 value, uint32 count);$/;"	p	signature:(uint16 *ptr, uint16 value, uint32 count)
kmemset32	util.c	/^void *kmemset32(uint32 *ptr, uint32 value, uint32 count)$/;"	f	signature:(uint32 *ptr, uint32 value, uint32 count)
kmemset32	util.h	/^void *kmemset32(uint32 *ptr, uint32 value, uint32 count);$/;"	p	signature:(uint32 *ptr, uint32 value, uint32 count)
kpage_dir	entry.s	/^kpage_dir:$/;"	l
kpage_table	entry.s	/^kpage_table:$/;"	l
kprintf	util.c	/^char *kprintf(char *str, const char *format, ...) {$/;"	f	signature:(char *str, const char *format, ...)
kprintf	util.h	/^char *kprintf(char *str, const char *format, ...);$/;"	p	signature:(char *str, const char *format, ...)
kstrcmp	util.c	/^int kstrcmp(char *str1, char *str2){$/;"	f	signature:(char *str1, char *str2)
kstrcmp	util.h	/^int kstrcmp(char *str1, char *str2);$/;"	p	signature:(char *str1, char *str2)
kstrncpy	util.c	/^void *kstrncpy(uint8 *destination, const uint8 *source, uint32 count)$/;"	f	signature:(uint8 *destination, const uint8 *source, uint32 count)
kstrncpy	util.h	/^void *kstrncpy(uint8 *destination, const uint8 *source, uint32 count);$/;"	p	signature:(uint8 *destination, const uint8 *source, uint32 count)
lapic_addr	cpu.h	/^	uint32 lapic_addr;$/;"	m	struct:MP_config	access:public
lapic_get	interrupts.c	/^int lapic_get(uint32 reg)$/;"	f	signature:(uint32 reg)
lapic_get	interrupts.h	/^int lapic_get(uint32 reg);$/;"	p	signature:(uint32 reg)
lapic_id	cpu.h	/^	uint8 lapic_id;$/;"	m	struct:MP_proc_entry	access:public
lapic_init	interrupts.c	/^void lapic_init()$/;"	f
lapic_set	interrupts.c	/^void lapic_set(uint32 reg, uint32 value)$/;"	f	signature:(uint32 reg, uint32 value)
lapic_set	interrupts.h	/^void lapic_set(uint32 reg, uint32 value);$/;"	p	signature:(uint32 reg, uint32 value)
lapic_ver	cpu.h	/^	uint8 lapic_ver;$/;"	m	struct:MP_proc_entry	access:public
ldt	gdt.c	/^	uint32 ldt;$/;"	m	struct:tss_entry	file:	access:public
length	cpu.h	/^	uint8 length;$/;"	m	struct:MP_float_ptr	access:public
length_high	mboot.h	/^	uint32 length_high;$/;"	m	struct:mmap	access:public
length_low	mboot.h	/^	uint32 length_low;$/;"	m	struct:mmap	access:public
list_clean	kmalloc.c	/^static void list_clean(struct mem_allocator *alloc, uint8 list)$/;"	f	file:	signature:(struct mem_allocator *alloc, uint8 list)
list_clean	kmalloc.c	/^static void list_clean(struct mem_allocator *alloc, uint8 list);$/;"	p	file:	signature:(struct mem_allocator *alloc, uint8 list)
list_get	kmalloc.c	/^static uint32 list_get(struct mem_allocator *alloc, uint16 list)$/;"	f	file:	signature:(struct mem_allocator *alloc, uint16 list)
list_put	kmalloc.c	/^static void list_put(struct mem_allocator *alloc, uint8 list, uint16 new_node)$/;"	f	file:	signature:(struct mem_allocator *alloc, uint8 list, uint16 new_node)
list_size	kmalloc.c	/^static inline uint32 list_size(uint8 list)$/;"	f	file:	signature:(uint8 list)
lock	interrupts.c	/^uint32 lock;$/;"	v
loop	entry.s	/^loop:$/;"	l
mboot	entry.s	/^mboot:$/;"	l
mboot	mboot.c	/^struct mboot {$/;"	s	file:
mboot::boot_device	mboot.c	/^	uint32 boot_device;$/;"	m	struct:mboot	file:	access:public
mboot::cmdline	mboot.c	/^	uint32 cmdline;$/;"	m	struct:mboot	file:	access:public
mboot::flags	mboot.c	/^	uint32 flags;$/;"	m	struct:mboot	file:	access:public
mboot::mem_lower	mboot.c	/^	uint32 mem_lower;$/;"	m	struct:mboot	file:	access:public
mboot::mem_upper	mboot.c	/^	uint32 mem_upper;$/;"	m	struct:mboot	file:	access:public
mboot::mmap_addr	mboot.c	/^	struct mmap *mmap_addr;$/;"	m	struct:mboot	typeref:struct:mboot::mmap	file:	access:public
mboot::mmap_length	mboot.c	/^	uint32 mmap_length;$/;"	m	struct:mboot	file:	access:public
mboot::mods_addr	mboot.c	/^	uint32 mods_addr;$/;"	m	struct:mboot	file:	access:public
mboot::mods_count	mboot.c	/^	uint32 mods_count;$/;"	m	struct:mboot	file:	access:public
mboot::syms	mboot.c	/^	uint32 syms[4];$/;"	m	struct:mboot	file:	access:public
mboot_load_modules	mboot.c	/^void mboot_load_modules(struct mboot *mboot)$/;"	f	signature:(struct mboot *mboot)
mboot_load_modules	mboot.h	/^void mboot_load_modules(struct mboot *mboot);$/;"	p	signature:(struct mboot *mboot)
mboot_parse	mboot.c	/^void mboot_parse(struct mboot *mboot)$/;"	f	signature:(struct mboot *mboot)
mboot_parse	mboot.h	/^void mboot_parse(struct mboot *mboot);$/;"	p	signature:(struct mboot *mboot)
mem_alloc	kmalloc.c	/^void *mem_alloc(struct mem_allocator *alloc, uint32 size)$/;"	f	signature:(struct mem_allocator *alloc, uint32 size)
mem_alloc	kmalloc.h	/^void *mem_alloc(struct mem_allocator *alloc, uint32 size);$/;"	p	signature:(struct mem_allocator *alloc, uint32 size)
mem_allocator	kmalloc.c	/^struct mem_allocator$/;"	s	file:
mem_allocator::heads	kmalloc.c	/^	uint16 heads[ALOCATORS];$/;"	m	struct:mem_allocator	file:	access:public
mem_allocator::nodes	kmalloc.c	/^	struct mem_node nodes[NODES];$/;"	m	struct:mem_allocator	typeref:struct:mem_allocator::mem_node	file:	access:public
mem_allocator_init	kmalloc.c	/^void mem_allocator_init(struct mem_allocator *aloc)$/;"	f	signature:(struct mem_allocator *aloc)
mem_allocator_init	kmalloc.h	/^void mem_allocator_init(struct mem_allocator *aloc);$/;"	p	signature:(struct mem_allocator *aloc)
mem_free	kmalloc.c	/^void mem_free(struct mem_allocator *alloc, void *addr, uint32 size)$/;"	f	signature:(struct mem_allocator *alloc, void *addr, uint32 size)
mem_free	kmalloc.h	/^void mem_free(struct mem_allocator *alloc, void *addr, uint32 size);$/;"	p	signature:(struct mem_allocator *alloc, void *addr, uint32 size)
mem_init	memory.c	/^void mem_init(struct mmap *mmap, uint32 length)$/;"	f	signature:(struct mmap *mmap, uint32 length)
mem_init	memory.h	/^void mem_init(struct mmap *map, uint32 length);$/;"	p	signature:(struct mmap *map, uint32 length)
mem_lower	mboot.c	/^	uint32 mem_lower;$/;"	m	struct:mboot	file:	access:public
mem_node	kmalloc.c	/^struct mem_node$/;"	s	file:
mem_node::addr	kmalloc.c	/^	uint32 addr;$/;"	m	struct:mem_node	file:	access:public
mem_node::next	kmalloc.c	/^	uint16 next;$/;"	m	struct:mem_node	file:	access:public
mem_phys_alloc	palloc.c	/^uint32 mem_phys_alloc()$/;"	f
mem_phys_alloc	palloc.h	/^uint32 mem_phys_alloc();$/;"	p	signature:()
mem_phys_dump	palloc.c	/^void mem_phys_dump()$/;"	f
mem_phys_dump	palloc.h	/^void mem_phys_dump();$/;"	p	signature:()
mem_phys_free	palloc.c	/^void mem_phys_free(uint32 addr)$/;"	f	signature:(uint32 addr)
mem_phys_free	palloc.h	/^void mem_phys_free(uint32 addr);$/;"	p	signature:(uint32 addr)
mem_phys_free_range	palloc.c	/^void mem_phys_free_range(uint32 addr, uint32 pages)$/;"	f	signature:(uint32 addr, uint32 pages)
mem_phys_free_range	palloc.h	/^void mem_phys_free_range(uint32 addr, uint32 pages);$/;"	p	signature:(uint32 addr, uint32 pages)
mem_phys_init	palloc.c	/^void mem_phys_init()$/;"	f
mem_phys_init	palloc.h	/^void mem_phys_init();$/;"	p	signature:()
mem_phys_reserve	palloc.c	/^void mem_phys_reserve(uint32 addr)$/;"	f	signature:(uint32 addr)
mem_phys_reserve	palloc.h	/^void mem_phys_reserve(uint32 addr);$/;"	p	signature:(uint32 addr)
mem_phys_reserve_range	palloc.c	/^void mem_phys_reserve_range(uint32 addr, uint32 pages)$/;"	f	signature:(uint32 addr, uint32 pages)
mem_phys_reserve_range	palloc.h	/^void mem_phys_reserve_range(uint32 addr, uint32 pages);$/;"	p	signature:(uint32 addr, uint32 pages)
mem_upper	mboot.c	/^	uint32 mem_upper;$/;"	m	struct:mboot	file:	access:public
memory_map	palloc.c	/^static uint32 memory_map[ENTRIES + 1];$/;"	v	file:
mmap	mboot.h	/^struct mmap {$/;"	s
mmap::base_high	mboot.h	/^	uint32 base_high;$/;"	m	struct:mmap	access:public
mmap::base_low	mboot.h	/^	uint32 base_low;$/;"	m	struct:mmap	access:public
mmap::length_high	mboot.h	/^	uint32 length_high;$/;"	m	struct:mmap	access:public
mmap::length_low	mboot.h	/^	uint32 length_low;$/;"	m	struct:mmap	access:public
mmap::size	mboot.h	/^	uint32 size;$/;"	m	struct:mmap	access:public
mmap::type	mboot.h	/^	uint32 type;$/;"	m	struct:mmap	access:public
mmap_addr	mboot.c	/^	struct mmap *mmap_addr;$/;"	m	struct:mboot	typeref:struct:mboot::mmap	file:	access:public
mmap_length	mboot.c	/^	uint32 mmap_length;$/;"	m	struct:mboot	file:	access:public
mod_end	mboot.c	/^	uint32 mod_end;$/;"	m	struct:module_info	file:	access:public
mod_start	mboot.c	/^	uint32 mod_start;$/;"	m	struct:module_info	file:	access:public
mods_addr	mboot.c	/^	uint32 mods_addr;$/;"	m	struct:mboot	file:	access:public
mods_count	mboot.c	/^	uint32 mods_count;$/;"	m	struct:mboot	file:	access:public
module_info	mboot.c	/^struct module_info{$/;"	s	file:
module_info::mod_end	mboot.c	/^	uint32 mod_end;$/;"	m	struct:module_info	file:	access:public
module_info::mod_start	mboot.c	/^	uint32 mod_start;$/;"	m	struct:module_info	file:	access:public
module_info::reserved	mboot.c	/^	uint32 reserved;$/;"	m	struct:module_info	file:	access:public
module_info::string	mboot.c	/^	uint32 string;$/;"	m	struct:module_info	file:	access:public
move_screen	screen.c	/^static void move_screen()$/;"	f	file:
mp_find	cpu.c	/^struct MP_float_ptr *mp_find()$/;"	f
mp_find	cpu.h	/^struct MP_float_ptr *mp_find();$/;"	p	signature:()
mp_slide	cpu.c	/^static void *mp_slide(uint8 *from, uint8 *to)$/;"	f	file:	signature:(uint8 *from, uint8 *to)
msg_queue	ipc.h	/^struct msg_queue$/;"	s
msg_queue::buf	ipc.h	/^	uint8 buf[QUEUE_LEN];$/;"	m	struct:msg_queue	access:public
msg_queue::header	ipc.h	/^	struct msg_queue_header header;$/;"	m	struct:msg_queue	typeref:struct:msg_queue::msg_queue_header	access:public
msg_queue_header	ipc.h	/^struct msg_queue_header$/;"	s
msg_queue_header::read	ipc.h	/^	uint16 read;$/;"	m	struct:msg_queue_header	access:public
msg_queue_header::write	ipc.h	/^	uint16 write;$/;"	m	struct:msg_queue_header	access:public
msg_queues	multitasking.h	/^	struct queue_descr msg_queues[PROC_MAX_QUEUES];$/;"	m	struct:process	typeref:struct:process::queue_descr	access:public
mv_cur	screen.c	/^static void mv_cur(char c) {$/;"	f	file:	signature:(char c)
name	drivers.h	/^	char name[32];$/;"	m	struct:driver	access:public
next	ipc.c	/^static inline int next(int value)$/;"	f	file:	signature:(int value)
next	kmalloc.c	/^	uint16 next;$/;"	m	struct:mem_node	file:	access:public
next	multitasking.h	/^	thread_id next;$/;"	m	struct:thread	access:public
node_free	kmalloc.c	/^static void node_free(struct mem_allocator *alloc, uint16 node)$/;"	f	file:	signature:(struct mem_allocator *alloc, uint16 node)
node_new	kmalloc.c	/^static uint16 node_new(struct mem_allocator *alloc, uint32 addr)$/;"	f	file:	signature:(struct mem_allocator *alloc, uint32 addr)
nodes	kmalloc.c	/^	struct mem_node nodes[NODES];$/;"	m	struct:mem_allocator	typeref:struct:mem_allocator::mem_node	file:	access:public
oem_id	cpu.h	/^	uint8 oem_id[8];$/;"	m	struct:MP_config	access:public
oem_table_ptr	cpu.h	/^	uint32 oem_table_ptr;$/;"	m	struct:MP_config	access:public
oem_table_size	cpu.h	/^	uint16 oem_table_size;$/;"	m	struct:MP_config	access:public
page_align	memory.c	/^inline uint32 page_align(uint32 addr)$/;"	f	signature:(uint32 addr)
page_align	memory.h	/^inline uint32 page_align(uint32 addr);$/;"	p	signature:(uint32 addr)
page_count	memory.c	/^inline uint32 page_count(uint32 bytes)$/;"	f	signature:(uint32 bytes)
page_count	memory.h	/^uint32 page_count(uint32 bytes);$/;"	p	signature:(uint32 bytes)
page_count	multitasking.h	/^	uint32 page_count;$/;"	m	struct:proc_section	access:public
page_dir_index	paging.c	/^inline uint32 page_dir_index(uint32 addr)$/;"	f	signature:(uint32 addr)
page_dir_index	paging.h	/^uint32 page_dir_index(uint32 addr);$/;"	p	signature:(uint32 addr)
page_dir_switch	paging.c	/^void page_dir_switch(uint32 newpdir)$/;"	f	signature:(uint32 newpdir)
page_dir_switch	paging.h	/^void page_dir_switch(uint32 newpdir);$/;"	p	signature:(uint32 newpdir)
page_entry	paging.c	/^inline uint32 page_entry(uint32 addr, uint32 flags)$/;"	f	signature:(uint32 addr, uint32 flags)
page_entry	paging.h	/^uint32 page_entry(uint32 addr, uint32 flags);$/;"	p	signature:(uint32 addr, uint32 flags)
page_table_index	paging.c	/^inline uint32 page_table_index(uint32 addr)$/;"	f	signature:(uint32 addr)
page_table_index	paging.h	/^uint32 page_table_index(uint32 addr);$/;"	p	signature:(uint32 addr)
page_table_virt_addr	paging.c	/^inline uint32 *page_table_virt_addr(int id)$/;"	f	signature:(int id)
page_table_virt_addr	paging.h	/^uint32 *page_table_virt_addr(int id);$/;"	p	signature:(int id)
paging_get_phys	paging.c	/^uint32 paging_get_phys(uint32 addr)$/;"	f	signature:(uint32 addr)
paging_get_phys	paging.h	/^uint32 paging_get_phys(uint32 addr);$/;"	p	signature:(uint32 addr)
paging_is_mapped	paging.c	/^uint8 paging_is_mapped(uint32 virt)$/;"	f	signature:(uint32 virt)
paging_is_mapped	paging.h	/^uint8 paging_is_mapped(uint32 virt);$/;"	p	signature:(uint32 virt)
paging_map	paging.c	/^void paging_map(uint32 virt, uint32 phys, uint32 flags)$/;"	f	signature:(uint32 virt, uint32 phys, uint32 flags)
paging_map	paging.h	/^void paging_map(uint32 virt, uint32 phys, uint32 flags);$/;"	p	signature:(uint32 virt, uint32 phys, uint32 flags)
parent	multitasking.h	/^	proc_id parent;$/;"	m	struct:thread	access:public
pdir	multitasking.h	/^	uint32 pdir;$/;"	m	struct:process	access:public
phys_addr	multitasking.h	/^	uint32 phys_addr;$/;"	m	struct:proc_section	access:public
pid	drivers.h	/^	proc_id pid;$/;"	m	struct:driver	access:public
port_read_16	ports.h	/^inline static uint16 port_read_16(uint16 port){$/;"	f	signature:(uint16 port)
port_read_8	ports.h	/^inline static uint8 port_read_8(uint16 port){$/;"	f	signature:(uint16 port)
port_write	ports.h	/^inline static void port_write(uint16 port, uint8 value){$/;"	f	signature:(uint16 port, uint8 value)
prev_tss	gdt.c	/^	uint32 prev_tss;$/;"	m	struct:tss_entry	file:	access:public
priorities	multitasking.h	/^	struct shed_queue priorities[MAX_PRIORITIES];$/;"	m	struct:shed_data	typeref:struct:shed_data::shed_queue	access:public
proc_create	multitasking.c	/^proc_id proc_create(struct proc_section text, struct proc_section data, struct proc_section bss, uint32 entry)$/;"	f	signature:(struct proc_section text, struct proc_section data, struct proc_section bss, uint32 entry)
proc_create	multitasking.h	/^proc_id proc_create(struct proc_section text, struct proc_section data, struct proc_section bss, uint32 entry);$/;"	p	signature:(struct proc_section text, struct proc_section data, struct proc_section bss, uint32 entry)
proc_cur	multitasking.c	/^proc_id proc_cur()$/;"	f
proc_cur	multitasking.h	/^proc_id proc_cur();$/;"	p	signature:()
proc_find_queue	multitasking.c	/^int proc_find_queue(proc_id pid)$/;"	f	signature:(proc_id pid)
proc_find_queue	multitasking.h	/^int proc_find_queue(proc_id pid);$/;"	p	signature:(proc_id pid)
proc_get_descr	multitasking.c	/^struct queue_descr proc_get_descr(proc_id pid, queue_id qid)$/;"	f	signature:(proc_id pid, queue_id qid)
proc_get_descr	multitasking.h	/^struct queue_descr proc_get_descr(proc_id pid, queue_id qid);$/;"	p	signature:(proc_id pid, queue_id qid)
proc_id	config.h	/^typedef uint16 proc_id;$/;"	t
proc_map_queue	multitasking.c	/^uint8 proc_map_queue(proc_id pid, queue_id send_to, queue_id receive_from)$/;"	f	signature:(proc_id pid, queue_id send_to, queue_id receive_from)
proc_map_queue	multitasking.h	/^uint8 proc_map_queue(proc_id pid, queue_id send_to, queue_id receive_from);$/;"	p	signature:(proc_id pid, queue_id send_to, queue_id receive_from)
proc_section	multitasking.h	/^struct proc_section$/;"	s
proc_section::page_count	multitasking.h	/^	uint32 page_count;$/;"	m	struct:proc_section	access:public
proc_section::phys_addr	multitasking.h	/^	uint32 phys_addr;$/;"	m	struct:proc_section	access:public
proc_section::virt_addr	multitasking.h	/^	uint32 virt_addr;$/;"	m	struct:proc_section	access:public
process	multitasking.h	/^struct process$/;"	s
process::bss	multitasking.h	/^	struct proc_section bss;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
process::data	multitasking.h	/^	struct proc_section data;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
process::msg_queues	multitasking.h	/^	struct queue_descr msg_queues[PROC_MAX_QUEUES];$/;"	m	struct:process	typeref:struct:process::queue_descr	access:public
process::pdir	multitasking.h	/^	uint32 pdir;$/;"	m	struct:process	access:public
process::text	multitasking.h	/^	struct proc_section text;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
processes	multitasking.c	/^struct process *processes[MAX_PROCESSES];$/;"	v	typeref:struct:process
prod_id	cpu.h	/^	uint8 prod_id[12];$/;"	m	struct:MP_config	access:public
queue_create	ipc.c	/^queue_id queue_create()$/;"	f
queue_create	ipc.h	/^queue_id queue_create();$/;"	p	signature:()
queue_descr	ipc.h	/^struct queue_descr$/;"	s
queue_descr::in_use	ipc.h	/^	uint8 in_use;$/;"	m	struct:queue_descr	access:public
queue_descr::rec_from	ipc.h	/^	queue_id rec_from;$/;"	m	struct:queue_descr	access:public
queue_descr::send_to	ipc.h	/^	queue_id send_to;$/;"	m	struct:queue_descr	access:public
queue_id	config.h	/^typedef uint16 queue_id;$/;"	t
queues	ipc.c	/^static struct msg_queue *queues[MAX_QUEUES];$/;"	v	typeref:struct:msg_queue	file:
read	ipc.h	/^	uint16 read;$/;"	m	struct:msg_queue_header	access:public
rec_from	ipc.h	/^	queue_id rec_from;$/;"	m	struct:queue_descr	access:public
regs_init	interrupts.c	/^void regs_init(struct thread_state *regs, uint32 stack, uint32 entry)$/;"	f	signature:(struct thread_state *regs, uint32 stack, uint32 entry)
regs_init	interrupts.h	/^void regs_init(struct thread_state *regs, uint32 stack, uint32 entry);$/;"	p	signature:(struct thread_state *regs, uint32 stack, uint32 entry)
regs_print	interrupts.c	/^void regs_print(struct thread_state *regs)$/;"	f	signature:(struct thread_state *regs)
regs_print	interrupts.h	/^void regs_print(struct thread_state *regs);$/;"	p	signature:(struct thread_state *regs)
reserved	cpu.h	/^	uint8 reserved[3];$/;"	m	struct:MP_float_ptr	access:public
reserved	mboot.c	/^	uint32 reserved;$/;"	m	struct:module_info	file:	access:public
sched_current	scheduler.c	/^struct Scheduler *sched_current()$/;"	f
sched_current	scheduler.h	/^struct Scheduler *sched_current();$/;"	p	signature:()
sched_init_all	scheduler.c	/^void sched_init_all()$/;"	f
sched_init_all	scheduler.h	/^void sched_init_all();$/;"	p	signature:()
sched_tick	scheduler.c	/^void sched_tick(struct Scheduler *this)$/;"	f	signature:(struct Scheduler *this)
sched_tick	scheduler.h	/^void sched_tick(struct Scheduler *this);$/;"	p	signature:(struct Scheduler *this)
schedulers	scheduler.c	/^struct Scheduler schedulers[MAX_CPU];$/;"	v	typeref:struct:Scheduler
screen_clear	screen.c	/^void screen_clear()$/;"	f
screen_clear	screen.h	/^void screen_clear();$/;"	p	signature:()
screen_getstyle	screen.c	/^static uint8 screen_getstyle(enum ScreenColor bg, enum ScreenColor fg)$/;"	f	file:	signature:(enum ScreenColor bg, enum ScreenColor fg)
screen_putchar	screen.c	/^static void screen_putchar(char c, uint8 style)$/;"	f	file:	signature:(char c, uint8 style)
screen_putstr	screen.c	/^void screen_putstr(char *c)$/;"	f	signature:(char *c)
screen_putstr	screen.h	/^void screen_putstr(char * buf);$/;"	p	signature:(char * buf)
screen_set_bg	screen.c	/^void screen_set_bg(uint8 color)$/;"	f	signature:(uint8 color)
screen_set_fg	screen.c	/^void screen_set_fg(uint8 color)$/;"	f	signature:(uint8 color)
section_enter	locks.c	/^void section_enter(uint32 *lock)$/;"	f	signature:(uint32 *lock)
section_enter	locks.h	/^void section_enter(uint32 *lock);$/;"	p	signature:(uint32 *lock)
section_leave	locks.c	/^void section_leave(uint32 *lock)$/;"	f	signature:(uint32 *lock)
section_leave	locks.h	/^void section_leave(uint32 *lock);$/;"	p	signature:(uint32 *lock)
selector	interrupts.c	/^	uint16 selector;$/;"	m	struct:idt_entry	file:	access:public
send_to	ipc.h	/^	queue_id send_to;$/;"	m	struct:queue_descr	access:public
server_get	drivers.c	/^int server_get(char *name)$/;"	f	signature:(char *name)
server_get	drivers.h	/^int server_get(char *name);$/;"	p	signature:(char *name)
server_irq_notify	drivers.c	/^void server_irq_notify(int irq)$/;"	f	signature:(int irq)
server_irq_notify	drivers.h	/^void server_irq_notify(int irq);$/;"	p	signature:(int irq)
server_set	drivers.c	/^int server_set(proc_id pid, char *name, int irq)$/;"	f	signature:(proc_id pid, char *name, int irq)
server_set	drivers.h	/^int server_set(proc_id pid, char *name, int irq);$/;"	p	signature:(proc_id pid, char *name, int irq)
sh_addr	elf.h	/^	uint32 sh_addr;$/;"	m	struct:elf_section	access:public
sh_addralign	elf.h	/^	uint32 sh_addralign;$/;"	m	struct:elf_section	access:public
sh_entsize	elf.h	/^	uint32 sh_entsize;$/;"	m	struct:elf_section	access:public
sh_flags	elf.h	/^	uint32 sh_flags;$/;"	m	struct:elf_section	access:public
sh_info	elf.h	/^	uint32 sh_info;$/;"	m	struct:elf_section	access:public
sh_link	elf.h	/^	uint32 sh_link;$/;"	m	struct:elf_section	access:public
sh_name	elf.h	/^	uint32 sh_name;$/;"	m	struct:elf_section	access:public
sh_offset	elf.h	/^	uint32 sh_offset;$/;"	m	struct:elf_section	access:public
sh_size	elf.h	/^	uint32 sh_size;$/;"	m	struct:elf_section	access:public
sh_type	elf.h	/^	uint32 sh_type;$/;"	m	struct:elf_section	access:public
shed_data	multitasking.h	/^struct shed_data$/;"	s
shed_data::cur_thread	multitasking.h	/^	thread_id cur_thread;$/;"	m	struct:shed_data	access:public
shed_data::priorities	multitasking.h	/^	struct shed_queue priorities[MAX_PRIORITIES];$/;"	m	struct:shed_data	typeref:struct:shed_data::shed_queue	access:public
shed_data::thread_count	multitasking.h	/^	uint32 thread_count;$/;"	m	struct:shed_data	access:public
shed_queue	multitasking.h	/^struct shed_queue$/;"	s
shed_queue::head	multitasking.h	/^	thread_id head;$/;"	m	struct:shed_queue	access:public
shed_queue::tail	multitasking.h	/^	thread_id tail;$/;"	m	struct:shed_queue	access:public
shed_queue_dequeue	multitasking.c	/^thread_id shed_queue_dequeue(struct shed_queue *queue)$/;"	f	signature:(struct shed_queue *queue)
shed_queue_enqueue	multitasking.c	/^void shed_queue_enqueue(struct shed_queue *queue, thread_id thread)$/;"	f	signature:(struct shed_queue *queue, thread_id thread)
sheduler_enqueue	multitasking.c	/^void sheduler_enqueue(thread_id thread)$/;"	f	signature:(thread_id thread)
sheduler_enqueue	multitasking.h	/^void sheduler_enqueue(thread_id thread);$/;"	p	signature:(thread_id thread)
sheduler_info	multitasking.c	/^struct shed_data sheduler_info[MAX_CPU];$/;"	v	typeref:struct:shed_data
sheduler_tick	multitasking.c	/^void sheduler_tick(struct thread_state *state)$/;"	f	signature:(struct thread_state *state)
sheduler_tick	multitasking.h	/^void sheduler_tick(struct thread_state *cur_state);$/;"	p	signature:(struct thread_state *cur_state)
signature	cpu.h	/^	uint8 signature[4];$/;"	m	struct:MP_config	access:public
signature	cpu.h	/^	uint8 signature[4];$/;"	m	struct:MP_float_ptr	access:public
size	gdt.c	/^	uint16 size;$/;"	m	struct:gdt	file:	access:public
size	interrupts.c	/^	uint16 size;$/;"	m	struct:idt	file:	access:public
size	mboot.h	/^	uint32 size;$/;"	m	struct:mmap	access:public
size_low	gdt.c	/^	uint16 size_low;$/;"	m	struct:gdt_entry	file:	access:public
size_t	config.h	/^typedef uint32 size_t;$/;"	t
specRev	cpu.h	/^	uint8 specRev;$/;"	m	struct:MP_config	access:public
ss	gdt.c	/^	uint32 ss;$/;"	m	struct:tss_entry	file:	access:public
ss	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
ss0	gdt.c	/^	uint32 ss0;$/;"	m	struct:tss_entry	file:	access:public
ss1	gdt.c	/^	uint32 ss1;$/;"	m	struct:tss_entry	file:	access:public
ss2	gdt.c	/^	uint32 ss2;$/;"	m	struct:tss_entry	file:	access:public
stack	entry.s	/^stack:$/;"	l
start	entry.s	/^start:$/;"	l
starting_priority	multitasking.h	/^	uint32 starting_priority;$/;"	m	struct:thread	access:public
string	mboot.c	/^	uint32 string;$/;"	m	struct:module_info	file:	access:public
switch_stack	scheduler.c	/^static void switch_stack(uint32 addr)$/;"	f	file:	signature:(uint32 addr)
syms	mboot.c	/^	uint32 syms[4];$/;"	m	struct:mboot	file:	access:public
syscall	syscall.c	/^void syscall(struct thread_state *state)$/;"	f	signature:(struct thread_state *state)
syscall	syscall.h	/^void syscall(struct thread_state *state);$/;"	p	signature:(struct thread_state *state)
tail	multitasking.h	/^	thread_id tail;$/;"	m	struct:shed_queue	access:public
task_switch	multitasking.c	/^void task_switch(struct thread_state *cur_state, thread_id from_thread, thread_id to_thread)$/;"	f	signature:(struct thread_state *cur_state, thread_id from_thread, thread_id to_thread)
task_switch	multitasking.h	/^void task_switch(struct thread_state *cur_state, thread_id from_thread, thread_id to_thread);$/;"	p	signature:(struct thread_state *cur_state, thread_id from_thread, thread_id to_thread)
text	multitasking.h	/^	struct proc_section text;$/;"	m	struct:process	typeref:struct:process::proc_section	access:public
thread	multitasking.h	/^struct thread$/;"	s
thread::current_priority	multitasking.h	/^	uint32 current_priority;$/;"	m	struct:thread	access:public
thread::ebp	multitasking.h	/^	uint32 ebp;$/;"	m	struct:thread	access:public
thread::eip	multitasking.h	/^	uint32 eip;$/;"	m	struct:thread	access:public
thread::esp	multitasking.h	/^	uint32 esp;$/;"	m	struct:thread	access:public
thread::kernel_stack	multitasking.h	/^	uint32 kernel_stack;$/;"	m	struct:thread	access:public
thread::next	multitasking.h	/^	thread_id next;$/;"	m	struct:thread	access:public
thread::parent	multitasking.h	/^	proc_id parent;$/;"	m	struct:thread	access:public
thread::starting_priority	multitasking.h	/^	uint32 starting_priority;$/;"	m	struct:thread	access:public
thread_count	multitasking.h	/^	uint32 thread_count;$/;"	m	struct:shed_data	access:public
thread_create	multitasking.c	/^thread_id thread_create(proc_id parent, uint32 entry)$/;"	f	signature:(proc_id parent, uint32 entry)
thread_create	multitasking.h	/^thread_id thread_create(proc_id parent, uint32 entry);$/;"	p	signature:(proc_id parent, uint32 entry)
thread_id	config.h	/^typedef uint16 thread_id;$/;"	t
thread_state	interrupts.h	/^struct thread_state{$/;"	s
thread_state::cs	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
thread_state::ds	interrupts.h	/^	uint32 ds;$/;"	m	struct:thread_state	access:public
thread_state::eax	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::ebp	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::ebx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::ecx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::edi	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::edx	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::eflags	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
thread_state::eip	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
thread_state::err	interrupts.h	/^	uint32 int_id, err;$/;"	m	struct:thread_state	access:public
thread_state::esi	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::esp	interrupts.h	/^	uint32 edi, esi, ebp, esp, ebx, edx, ecx, eax;$/;"	m	struct:thread_state	access:public
thread_state::int_id	interrupts.h	/^	uint32 int_id, err;$/;"	m	struct:thread_state	access:public
thread_state::ss	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
thread_state::useresp	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
threads	multitasking.c	/^struct thread *threads[MAX_THREADS];$/;"	v	typeref:struct:thread
tmp_page_dir	entry.s	/^tmp_page_dir:$/;"	l
trap	gdt.c	/^	uint16 trap;$/;"	m	struct:tss_entry	file:	access:public
tss	gdt.c	/^static struct tss_entry tss[MAX_CPU];$/;"	v	typeref:struct:tss_entry	file:
tss_entry	gdt.c	/^struct tss_entry$/;"	s	file:
tss_entry::cr3	gdt.c	/^	uint32 cr3;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::cs	gdt.c	/^	uint32 cs;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ds	gdt.c	/^	uint32 ds;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::eax	gdt.c	/^	uint32 eax;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ebp	gdt.c	/^	uint32 ebp;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ebx	gdt.c	/^	uint32 ebx;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ecx	gdt.c	/^	uint32 ecx;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::edi	gdt.c	/^	uint32 edi;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::edx	gdt.c	/^	uint32 edx;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::eflags	gdt.c	/^	uint32 eflags;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::eip	gdt.c	/^	uint32 eip;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::es	gdt.c	/^	uint32 es;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::esi	gdt.c	/^	uint32 esi;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::esp	gdt.c	/^	uint32 esp;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::esp0	gdt.c	/^	uint32 esp0;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::esp1	gdt.c	/^	uint32 esp1;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::esp2	gdt.c	/^	uint32 esp2;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::fs	gdt.c	/^	uint32 fs;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::gs	gdt.c	/^	uint32 gs;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::iomap_base	gdt.c	/^	uint16 iomap_base;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ldt	gdt.c	/^	uint32 ldt;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::prev_tss	gdt.c	/^	uint32 prev_tss;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ss	gdt.c	/^	uint32 ss;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ss0	gdt.c	/^	uint32 ss0;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ss1	gdt.c	/^	uint32 ss1;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::ss2	gdt.c	/^	uint32 ss2;$/;"	m	struct:tss_entry	file:	access:public
tss_entry::trap	gdt.c	/^	uint16 trap;$/;"	m	struct:tss_entry	file:	access:public
tss_set_stack	gdt.c	/^void tss_set_stack(uint32 cpu, uint32 stack)$/;"	f	signature:(uint32 cpu, uint32 stack)
tss_set_stack	gdt.h	/^void tss_set_stack(uint32 cpu, uint32 stack);$/;"	p	signature:(uint32 cpu, uint32 stack)
type	cpu.h	/^	uint8 type;$/;"	m	struct:MP_ioapic_entry	access:public
type	cpu.h	/^	uint8 type;$/;"	m	struct:MP_proc_entry	access:public
type	mboot.h	/^	uint32 type;$/;"	m	struct:mmap	access:public
uint16	config.h	/^typedef unsigned short uint16;$/;"	t
uint32	config.h	/^typedef unsigned int uint32;$/;"	t
uint8	config.h	/^typedef unsigned char uint8;$/;"	t
useresp	interrupts.h	/^	uint32 eip, cs, eflags, useresp, ss;$/;"	m	struct:thread_state	access:public
ver	cpu.h	/^	uint8 ver;$/;"	m	struct:MP_ioapic_entry	access:public
version	cpu.h	/^	uint8 version;$/;"	m	struct:MP_float_ptr	access:public
videomem	screen.c	/^unsigned short *videomem = (unsigned short*)0xB8000;$/;"	v
virt_addr	multitasking.h	/^	uint32 virt_addr;$/;"	m	struct:proc_section	access:public
write	ipc.h	/^	uint16 write;$/;"	m	struct:msg_queue_header	access:public
zero	interrupts.c	/^	uint8 zero;$/;"	m	struct:idt_entry	file:	access:public
